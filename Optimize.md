# 优化文章

> 22373080 沈锎

[TOC]

## 优化概览

性能测试结果如下表：

|         Item         |   # 1   |  # 2  |   # 3    | # 4 |     # 5      |     # 6     |  # 7  |     # 8      |
| :------------------: | :-----: | :---: | :------: | :-: | :----------: | :---------: | :---: | :----------: |
|         Bare         |   380   | 10341 |  10310   | 809 |   2.8809E7   |  1.1409E7   | 11698 |   5.1626E7   |
|       Mem2Reg        |   221   | 8262  |   8876   | 660 |   2.4107E7   | **7994523** | 9407  | **1.8880E7** |
|         ADCE         |   221   | 7872  |   8876   | 658 |   2.4067E7   |   7890406   | 9407  |   1.9944E7   |
|      ConstFold       |   221   | 7908  |   8781   | 653 |   2.4067E7   |   7962172   | 9149  |   2.0063E7   |
|       MergeBB        |   209   | 7566  |   8709   | 613 |   2.3317E7   |   7555153   | 8747  |   1.8680E7   |
|         LVN          |   209   | 7594  |  12397   | 613 |   2.3317E7   |   7587337   | 8711  |   1.8600E7   |
|     LVN-Enhanced     |   209   | 7590  |  12397   | 613 |   2.6667E7   |   7575403   | 8686  |   1.7297E7   |
|   RegAllocate-Fix    |   209   | 7726  |  12397   | 613 |   2.6667E7   |   7452291   | 8686  |   1.7297E7   |
| Global Const Inline  |   209   | 7554  |  12397   | 552 |   2.6667E7   |   7603491   | 8686  |   1.8640E7   |
|       ~~LVN~~        |   209   | 7590  | **8709** | 552 |   2.3317E7   |   7654945   | 8747  |   1.7337E7   |
|   More Global Regs   |   209   | 7534  |   8709   | 552 |   2.3397E7   |   7569625   | 8747  |   1.5674E7   |
|  Peephole-Main-Func  | **162** | 7487  |   8602   | 509 |   2.3077E7   |   7041250   | 8720  |   1.5633E7   |
|      Multi-Div       |   162   | 6983  |   8602   | 509 | **2.0493E7** | **5803516** | 8715  |   1.5753E7   |
|   Peephole-Add-Sub   |   162   | 6967  |   8590   | 505 |   2.0238E7   |   5786608   | 8701  |   1.5743E7   |
| Loop Invariant Hoist |   162   | 6932  |   8590   | 505 |   2.0218E7   |   5692066   | 8701  |  **359378**  |
|   More Global Regs   |   162   | 6932  |   8590   | 505 |   2.0218E7   |   5657938   | 8701  |    358982    |

从上到下表示依次增加（或移除 LVN）这些优化措施。从中可以观察得到，**Mem2Reg** 是**整体优化效果最显著**的，乘除法优化对部分点有较为明显的优化，而**循环不变式外提**对最后一个测试点有显著的性能提升。同时，**局部值编号**（LVN）的优化效果并不显著，甚至存在**负优化**现象，推测为局部变量生命周期的延长，给寄存器分配带来的压力要大于减少计算量带来的收益，因此在最终将其移除。

在代码中，**移除 Phi 指令**与**寄存器分配**内置，无法单独开启或者关闭。

整体进行的优化为（按首次施加顺序）：Mem2Reg、（激进的）死代码删除、循环不变式外提、常数折叠、乘法强度削弱、控制流化简、除法强度削弱（目标代码生成时进行）、Phi 指令移除、寄存器分配（临时：线性扫描；全局：图着色）、窥孔优化。

## LLVM IR 分析（`analysises`）

对 IR 的分析也成为一系列 Pass，我的实现中包括：控制流分析、支配树分析、循环分析。

### 控制流分析 `AnalyseControlFlowGraph`

此处的分析聚焦于**单个函数中**基本块的**前驱与后继**，实现较为简单。整体思路为使用**广度优先搜索**方法，从入口块开始，通过维护访问队列，注意访问，并构建访问过程中生成的前驱与后继关系，记录在函数对象中。

### 支配树分析 `AnalyseDominatorTree`

首先得到支配关系，采用 [Algorithms for Finding Dominators in Directed Graphs, Page 25, Algorithm 3](https://www.cs.au.dk/~gerth/advising/thesis/henrik-knakkegaard-christensen.pdf) 给出的算法进行，伪代码如下：

```
for w in V do
    traverse V', V' <- V - {w}
    w dominates vertices not visited
end for

For each vertex w in V, traverse the graph starting from *the root*.
```

概括而言，即为**删点法**，如果删去某一个基本块 `w`，会导致某些基本块从起点开始不可达，那么 `w` 就支配这些节点。

接着，找出直接支配节点，对于某个基本块 `block`，以及支配它的全部节点 `dominatorSet`，对于 `dominatorSet` 中的某个节点 `dominator`，以及**另一个** `dominatorSet` 中不为 `block` 的节点 `other`，如果 `dominator` 支配 `other`，则 `dominator` 不为 `block` 的直接支配节点。

换句话说，`block` 的直接支配节点，为支配 `block` 的节点中，**不支配其他节点的节点**（当然也不能是自己）。

### 循环分析 `AnalyseLoop`

分析的目标是找出一个函数中的循环，并找出循环的子循环、父循环，以及循环相关基本块信息。相关内容的定义参见 LLVM 官网的下列图片：

![相关定义，https://llvm.org/docs/_images/loop-terminology.svg](https://llvm.org/docs/_images/loop-terminology.svg)

循环的核心构成要素是 `backEdge`，即 “回边”，定义为 “**B 到 A 的边存在，且 A dom B**”。

在寻找时，按照直接支配关系的后序遍历，按照定义查找回边，并通过回边，构建与循环的对应关系。对于某个成为 `header` 的基本块，存在多个指向它的回边，则考虑识别子循环。这里并不考虑上图这样的复杂循环，而假定不会出现两个不相干循环共享同一个 `header` 的情况。

直接参考：[compiler2024-x/LoopAnalysis.java](https://gitlab.eduxiji.net/educg-group-26173-2487151/T202410006203104-3288/-/blame/main/src/pass/ir/LoopAnalysis.java)，原始参考未作记录。

## LLVM IR 转换（`transforms`）

### 访存转寄存器（`Mem2Reg`）

参考：<https://roife.github.io/posts/mem2reg-pass/>；[compiler2024-x/Mem2Reg.java](https://gitlab.eduxiji.net/educg-group-26173-2487151/T202410006203104-3288/-/blame/main/src/pass/ir/Mem2Reg.java)

核心思路为找到**支配边界**，并在支配边界插入 phi 指令，并进行变量的重命名。

### （激进的）死代码删除（`AggressiveDeadCodeEliminate`）

首先定义所有**函数调用**，**函数返回**，**访存操作**为**有效指令**，一条指令只有直接或间接与他们产生依赖，才被标记为有效。

在找到所有的初始有效指令后，遍历每个基本块的基本指令，如果**某个基本块含有有效指令**，则为有效块，它的 phi 指令的**全部来源块**也标记为有效，并将新加入的有效块的**最后一条跳转指令**标记为有效。如果某条指令定义的值被有效指令引用，则也将其标记为有效。

如上，直至全部检查完成。最后，**移除没有被标记的指令**与基本块，同时需要删除相关的跳转语句（在实际编程中，我没有删除非有效的块，导致除了一些 llvm 的语法问题）。

参考：<https://www.cnblogs.com/lixingyang/p/17728846.html>

### 循环不变式外提（`LoopHoist`）

将循环中的计算**尽可能移出循环体**。如果某一条计算没有直接或间接依赖于循环内部的变量、每次循环计算得到的结果必然相等，则可以将其提升到循环之前执行。

在遍历每一个循环时，要使子循环优先被处理，此时，在 `header` 与其前驱之间**插入一个基本块**，接下来可以开始对可提升的内容进行判断。

首先，遍历循环体内的每一个指令，**标记左值为被定值**。接着，再次查找每一条指令（可以限定类型，只对计算指令或没有副作用的函数调用等进行），如果**使用了被定值的变量**，则**标记为不可提取**。

最后，将所有没有被标记的可以被提取的指令，提取如新增基本块中即可。

直接参考：[compiler2024-x/LoopHoist.java](https://gitlab.eduxiji.net/educg-group-26173-2487151/T202410006203104-3288/-/blame/main/src/pass/ir/LoopHoist.java)，原始参考未作记录。

### 常数折叠（`ConstantFolding`）

实现得比较简单，遍历每条指令，如果是二元计算指令或者比较指令，并且**两个操作数均为常数**（对于 const 变量，在另一个 pass 中进行处理，不赘述）时，进行计算，将结果存储在与**所定值的变量关联的对象中**。接着，遍历全部**使用该变量**的语句，进行替换，再次进行常数折叠，直至全部完成。

### 乘法强度削弱（`MultiplySimplify`）

实现得比较简单，针对乘数为一个变量（`operand`）、一个常数的情况，对于常数，有下列几类：

- 常数为 0，直接将结果替换为 0
- 常数为 1，直接将结果替换为另一个操作数
- 常数为 -1，转换为 `res = 0 - operand`
- 常数为正数：
  - 若为 $2^k$，则转换为 `res = operand << k`
  - 若为 $2^x + 2^y$，则转换为 `res = (operand << x) + (operand << y)`
  - 若为 $2^x - 2^y$，则转换为 `res = (operand << x) - (operand << y)`

### 控制流化简（`ControlFlowSimplify`）

实现两点：对于**条件为常数**的跳转指令，转换为直接的跳转指令，并移除另一条边；如果某个基本块**只有一个前驱**，且这个前驱**只有一个后继**，将它们合并。

## 目标代码生成时

### 除法强度削弱（`MipsGenerator#buildFastDivide`）

只针对除数为平凡值（1, -1）与 2 的幂次进行处理，尝试处理更加复杂的情况，但没有成功。

参考：<https://www.cnblogs.com/czlnb/p/15761065.html>

### Phi 指令移除（`MipsFunctionRemovePhi`）

实现得较为简单。对于每一条 phi 指令，有两种情况。如果来源块只有一个后继（即这个基本块只能跳转到 phi 指令所在块），则直接在末尾插入赋值语句。注意，为了实现同步赋值，应该使用**一系列临时虚拟寄存器**，**先将来源值全部保存**，而后再统一将临时虚拟寄存器中的值赋值给目标寄存器。

如果来源块有多个后继，则在它们中间再插入一个基本块，在基本块中完成赋值。

注意，Phi 指令移除后，**静态单赋值**的特性将会消失，因此我是对**使用虚拟寄存器的 Mips 代码**进行的。

### 寄存器分配（`MipsFunctionRegisterAllocate`）

针对跨基本块活跃的变量，采用图着色方法分配全局寄存器。针对不跨基本块活跃的变量，采用简单的线性扫描方式分配局部寄存器。

> 注意，函数调用并不会导致 LLVM IR 的基本块分裂，但跨函数调用活跃的变量也应该分配全局寄存器。

所谓线性扫描，被我实现成了先来先拿，不够用就逐出，事实上效果并不十分理想。

## 目标代码优化

### 窥孔优化（`Peephole`）

只识别了极为有限的情况：`a = a + 0, a = a - 0, a = a + $zero`，将它们移除。
